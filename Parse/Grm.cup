package Parse;

import Symbol.*;
import java.util.ArrayList;
import java.util.List;

action code {: 
    static Symbol sym(String s) {
        return Symbol.symbol(s);
    }
:};

parser code  {: 
  Lexer lexer;
  ErrorMsg.ErrorMsg errorMsg;

  public void syntax_error(java_cup.runtime.Symbol current) {
    report_error("Syntax error (" + current.sym + ")", current);
  }

  public void report_error(String message, java_cup.runtime.Symbol info) {
    errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg = err;
    lexer = l;
  }
:};

scan with {: return lexer.nextToken(); :};

// -------------------
// Terminals
// -------------------
terminal String ID, STRING_LITERAL;
terminal Integer DECIMAL_LITERAL;
terminal Character CHAR_LITERAL;
terminal INT, COMMA, COLON, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK,
	LBRACE, RBRACE, PLUS, MINUS, TIMES, DIVIDE, EQ, NEQ, LT, LE,
	GT, GE, AND, OR, ASSIGN, IF, ELSE, WHILE, FOR,
	DO, BREAK, FUN, VAR, VOLATILE, REGISTER, CONTINUE, TYPEDEF,
	STRUCT, STATIC, SIZEOF, RETURN, EXTERN, DOUBLE,
	UNION, SHORT, FLOAT, CONST, VOID, LONG, GOTO, ENUM,
	CHAR, AUTO, RSHIFTASSIGN, LSHIFTASSIGN, ELIPSES, BWISEORASSIGN,
	BWISEXORASSIGN, RSHIFT, LSHIFT, DIVASSIGN, ARROW, SUBASSIGN, DECREMENT,
	ADDASSIGN, INCREMENT, MULASSIGN, BWISEANDASSIGN, MODASSIGN, TILDE,
	BWISEOR, BWISEXOR, BWISEAND, BWISENOT,
	MODULUS, CASE, DEFAULT, SIGNED, SWITCH, UNSIGNED, ANDAND, OROR, NOT, QUESTION, HASH, DOT;

// -------------------
// Non-terminals
// -------------------
non terminal Absyn.Exp Exp;
non terminal Absyn.Var Var;
non terminal Absyn.Exp primary_expression, postfix_expression, unary_expression,
    cast_expression, multiplicative_expression, additive_expression,
    shift_expression, relational_expression, equality_expression,
    and_expression, exclusive_or_expression, inclusive_or_expression,
    logical_and_expression, logical_or_expression,
    conditional_expression, assignment_expression, expression;
non terminal java.util.List argument_expression_list, argument_expression_list_opt;
non terminal Object ;
non terminal Absyn.Dec declaration;
non terminal Absyn.Type type;
non terminal java.util.List bitfield_list;
non terminal String bitfield;

non terminal Absyn.Type type_name;
non terminal String unary_operator;
non terminal String assignment_operator;

non terminal Absyn.Exp initialization;
non terminal java.util.List parameters;
non terminal Absyn.CompoundStmt compound_statement;

non terminal java.util.List type_augments;
non terminal Absyn.Type type_augment;

non terminal java.util.List declaration_list;
non terminal java.util.List statement_list;
non terminal Absyn.Param parameter;
non terminal java.util.List parameter_list;
non terminal Absyn.Stmt statement;

start with Exp;

// -------------------
// Grammar Rules
// -------------------

// -------------- Expression Entry -----------------
Exp ::= error:e
      {: RESULT = new Absyn.SeqExp(eleft, null); :}
    | Var:v
      {: RESULT = new Absyn.VarExp(vleft, v); :}
    ;

// -------------- Variable -----------------
Var ::= ID:n
      {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
    ;

// -------------- Primary -----------------
primary_expression ::= ID:n {: RESULT = new Absyn.VarExp(nleft, new Absyn.SimpleVar(nleft, sym(n))); :}
    | DECIMAL_LITERAL:n {: RESULT = new Absyn.IntExp(nleft, n); :}
    | CHAR_LITERAL:c {: RESULT = new Absyn.CharExp(cleft, c); :}
    | STRING_LITERAL:s {: RESULT = new Absyn.StrExp(sleft, s); :}
    | LPAREN expression:e RPAREN {: RESULT = e; :}
    ;

// ------------------ Postfix ------------------
postfix_expression ::= primary_expression:e
    {: RESULT = e; :}
    | postfix_expression:p LBRACK expression:e RBRACK 
        {: RESULT = new Absyn.ArrayAccessExp(pleft, ((Absyn.VarExp)p).var, e); :}
    | postfix_expression:e DOT ID:n 
        {: RESULT = new Absyn.VarExp(nleft, new Absyn.DotVar(nleft, ((Absyn.VarExp)e).var, sym(n))); :}
    | postfix_expression:e ARROW ID:n 
        {: RESULT = new Absyn.VarExp(nleft, new Absyn.ArrowVar(nleft, ((Absyn.VarExp)e).var, sym(n))); :}
    | postfix_expression:e INCREMENT:n 
        {: RESULT = new Absyn.PostIncExp(nleft, ((Absyn.VarExp)e).var); :}
    | postfix_expression:e DECREMENT:n 
        {: RESULT = new Absyn.PostDecExp(nleft, ((Absyn.VarExp)e).var); :}
    | postfix_expression:p LPAREN argument_expression_list_opt:a RPAREN 
        {: RESULT = new Absyn.FuncCallExp(pleft, ((Absyn.VarExp)p).var, a == null ? new java.util.ArrayList<>() : a); :}
    ;

// -------------- Argument List -----------------
argument_expression_list_opt ::= /* empty */ {: RESULT = null; :}
    | argument_expression_list:e {: RESULT = e; :}
    ;

argument_expression_list ::= assignment_expression:e 
    {: 
        ArrayList<Absyn.Exp> list = new ArrayList<>();
        list.add(e);
        RESULT = list; 
    :}
    | argument_expression_list:l COMMA assignment_expression:e 
        {: 
            l.add(e);
            RESULT = l; 
        :}
    ;

// -------------- Declaration & Bitfield -----------------
declaration ::= VAR bitfield_list:n type:t ID:d initialization:i SEMICOLON {: RESULT = new Absyn.VarDec(nleft, n, t, sym(d), i); :}
    | FUN bitfield_list:n type:t ID:d parameters:p compound_statement:c {: RESULT = new Absyn.FunctionDec(nleft, n, t, sym(d), p, c); :}
    ;

bitfield ::= STATIC   {: RESULT = "static"; :}
           | VOLATILE {: RESULT = "volatile"; :}
           | CONST    {: RESULT = "const"; :}
           | EXTERN   {: RESULT = "extern"; :}
           | REGISTER {: RESULT = "register"; :}
           ;

bitfield_list ::= /* empty */
    {: RESULT = new ArrayList<String>(); :}
    |
    bitfield_list:l bitfield:b
    {: 
        l.add(b);
        RESULT = l;
    :}
    ;


initialization ::= /* empty */ {: RESULT = null; :}
                 | ASSIGN expression:e {: RESULT = e; :}
                 ;

parameters ::= LPAREN RPAREN {: RESULT = new ArrayList<Absyn.Param>(); :}
            | LPAREN parameter_list:p RPAREN {: RESULT = p; :}
            ;

parameter_list ::= parameter:p
                 {: 
                    ArrayList<Absyn.Param> list = new ArrayList<>();
                    list.add(p);
                    RESULT = list;
                 :}
                | parameter_list:l COMMA parameter:p
                 {: 
                    l.add(p);
                    RESULT = l;
                 :}
                ;

parameter ::= bitfield_list:b type:t ID:n {: RESULT = new Absyn.Param(nleft, b, t, sym(n)); :};

compound_statement ::= LBRACE declaration_list:d statement_list:s RBRACE {: RESULT = new Absyn.CompoundStmt(dleft, d, s); :};

declaration_list ::= /* empty */ {: RESULT = new ArrayList<Absyn.Dec>(); :}
                | declaration_list:l declaration:d 
                {:
                    l.add(d);
                    RESULT = l;
                :}
                ;

statement_list ::= /* empty */ {: RESULT = new ArrayList<Absyn.Stmt>(); :}
                | statement_list:l statement:s 
                {:
                    l.add(s);
                    RESULT = l;
                :}
                ;

statement ::= expression:e SEMICOLON
             {: RESULT = new Absyn.ExprStmt(eleft, e); :}

           | compound_statement:c
             {: RESULT = c; :}

           | RETURN expression:e SEMICOLON
             {: RESULT = new Absyn.ReturnStmt(eleft, e); :}

           | IF LPAREN expression:cond RPAREN statement:thenPart
             {: RESULT = new Absyn.IfStmt(condleft, cond, thenPart, null); :}

           | IF LPAREN expression:cond RPAREN statement:thenPart ELSE statement:elsePart
             {: RESULT = new Absyn.IfStmt(condleft, cond, thenPart, elsePart); :}

           | WHILE LPAREN expression:cond RPAREN statement:body
             {: RESULT = new Absyn.WhileStmt(condleft, cond, body); :}

           | BREAK:b SEMICOLON
             {: RESULT = new Absyn.BreakStmt(bleft); :}

           | CONTINUE:c SEMICOLON
             {: RESULT = new Absyn.ContinueStmt(cleft); :}

           | FOR LPAREN expression:e1 SEMICOLON expression:e2 SEMICOLON expression:e3 RPAREN statement:s
                {: RESULT = new Absyn.ForStmt(e1left, e1, e2, e3, s); :}

           | DO statement:s WHILE LPAREN expression:e RPAREN SEMICOLON
                {: RESULT = new Absyn.DoWhileStmt(sleft, s, e); :}
           ;

type ::= type_name:t {: RESULT = t; :}
       | type_name:t type_augments:a
        {: 
            Absyn.Type base = t;
            for (int i = a.size() - 1; i >= 0; i--) {
                Absyn.Type augment = (Absyn.Type)a.get(i);

                if (augment instanceof Absyn.PointerType) {
                    ((Absyn.PointerType)augment).baseType = base;
                } else if (augment instanceof Absyn.ArrayType) {
                    ((Absyn.ArrayType)augment).baseType = base;
                }
                base = augment;
            }
            RESULT = base;
        :}
       ;

type_name ::= INT:t {: RESULT = new Absyn.TypeName(tleft, "int"); :}
            | CHAR:t {: RESULT = new Absyn.TypeName(tleft, "char"); :}
            | VOID:t {: RESULT = new Absyn.TypeName(tleft, "void"); :}
            ;

type_augments ::= type_augment:t
                {: 
                    ArrayList<Absyn.Type> list = new ArrayList<>();
                    list.add(t);
                    RESULT = list;
                :}
                | type_augments:l type_augment:t
                {: 
                    l.add(t);
                    RESULT = l;
                :}
                ;

type_augment ::= TIMES:t
               {: RESULT = new Absyn.PointerType(tleft); :}
               | LBRACK:t RBRACK
               {: RESULT = new Absyn.ArrayType(tleft, null); :}
               | LBRACK:t expression:e RBRACK
               {: RESULT = new Absyn.ArrayType(tleft, e); :}
               ;

// -------------- Unary -----------------
unary_expression ::= postfix_expression:p {: RESULT = p; :}
    | INCREMENT unary_expression:e {: RESULT = new Absyn.PreIncExp(eleft, ((Absyn.VarExp)e).var); :}
    | DECREMENT unary_expression:e {: RESULT = new Absyn.PreDecExp(eleft, ((Absyn.VarExp)e).var); :}
    | unary_operator:o cast_expression:c {: RESULT = new Absyn.UnaryOpExp(oleft, o, c); :}
    | SIZEOF:s LPAREN type_name:n RPAREN {: RESULT = new Absyn.SizeofUnaryExp(sleft, n); :}
    ;

unary_operator ::= AND | TIMES | PLUS | MINUS | TILDE | NOT;

// -------------- Cast -----------------
cast_expression ::= unary_expression {: RESULT = $1; :};

// -------------- Multiplicative -----------------
multiplicative_expression ::= cast_expression {: RESULT = $1; :}
    | multiplicative_expression TIMES cast_expression {: RESULT = null; :}
    | multiplicative_expression DIVIDE cast_expression {: RESULT = null; :}
    | multiplicative_expression MODULUS cast_expression {: RESULT = null; :}
    ;

// -------------- Additive -----------------
additive_expression ::= multiplicative_expression {: RESULT = $1; :}
    | additive_expression PLUS multiplicative_expression {: RESULT = null; :}
    | additive_expression MINUS multiplicative_expression {: RESULT = null; :}
    ;

// -------------- Shift -----------------
shift_expression ::= additive_expression {: RESULT = $1; :}
    | shift_expression LSHIFT additive_expression {: RESULT = null; :}
    | shift_expression RSHIFT additive_expression {: RESULT = null; :}
    ;

// -------------- Relational -----------------
relational_expression ::= shift_expression {: RESULT = $1; :}
    | relational_expression LT shift_expression {: RESULT = null; :}
    | relational_expression GT shift_expression {: RESULT = null; :}
    | relational_expression LE shift_expression {: RESULT = null; :}
    | relational_expression GE shift_expression {: RESULT = null; :}
    ;

// -------------- Equality -----------------
equality_expression ::= relational_expression {: RESULT = $1; :}
    | equality_expression EQ relational_expression {: RESULT = null; :}
    | equality_expression NEQ relational_expression {: RESULT = null; :}
    ;

// -------------- Bitwise -----------------
and_expression ::= equality_expression {: RESULT = $1; :}
    | and_expression BWISEAND equality_expression {: RESULT = null; :}
    ;

exclusive_or_expression ::= and_expression {: RESULT = $1; :}
    | exclusive_or_expression BWISEXOR and_expression {: RESULT = null; :}
    ;

inclusive_or_expression ::= exclusive_or_expression {: RESULT = $1; :}
    | inclusive_or_expression BWISEOR exclusive_or_expression {: RESULT = null; :}
    ;

// -------------- Logical -----------------
logical_and_expression ::= inclusive_or_expression {: RESULT = $1; :}
    | logical_and_expression ANDAND inclusive_or_expression {: RESULT = null; :}
    ;

logical_or_expression ::= logical_and_expression {: RESULT = $1; :}
    | logical_or_expression OROR logical_and_expression {: RESULT = null; :}
    ;

// -------------- Conditional -----------------
conditional_expression ::= logical_or_expression {: RESULT = $1; :}
    | logical_or_expression QUESTION expression COLON conditional_expression {: RESULT = null; :}
    ;

// -------------- Assignment -----------------
assignment_expression ::= conditional_expression {: RESULT = $1; :}
    | unary_expression assignment_operator assignment_expression {: RESULT = null; :}
    ;

assignment_operator ::= ASSIGN | MULASSIGN | DIVASSIGN | MODASSIGN | ADDASSIGN | SUBASSIGN | LSHIFTASSIGN | RSHIFTASSIGN | BWISEANDASSIGN | BWISEXORASSIGN | BWISEORASSIGN;

// -------------- Expression (comma-separated) -----------------
expression ::= assignment_expression {: RESULT = $1; :}
    | expression COMMA assignment_expression {: RESULT = null; :}
    ;